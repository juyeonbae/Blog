#### 1\. 성능 데이터 모델링이란?

: 데이터베이스 성능 향상을 목적으로 설계 단계의 데이터 모델링 때부터 성능과 관련된 사항이 데이터 모델링에 반영될 수 있도록 하는 것

*   _만약 어떤 트랜잭션이 성능이 저하되면 안 되는 특징을 갖고 있다면,_
    *   프로젝트 초기에 운영환경에 대비한 테스트 환경을 구현하고 그곳에 트랜잭션을 발생시켜 실제 성능을 테스트해 봐야 한다. 
    *   이때, 데이터 모델의 구조도 변경하면서 어떠한 구조가 해당 사이트에 성능상 가장 적절한 구조인지 검토하여 성능이 좋은 모습으로 디자인 하는 전략이 요구된다. 
*   데이터의 증가가 빠를수록 성능 저하에 따른 성능 개선 비용은 증가한다.
*   데이터 모델은 성능을 튜닝하면서 변경이 될 수 있는 특징이 있다. 
*   분석/설계 단계에서 성능을 고려한 데이터 모델링을 수행할 경우 성능 저하에 따른 Rework 비용을 최소화 할 수 있는 기회를 갖는다. 

#### 2\. 성능 데이터 모델링 수행 절차 (데이터 모델링 단계에서 성능을 고려하기 위한) 

1.  데이터 모델링을 할 때 정규화를 정확하게 수행한다. 
2.  데이터베이스 용량 산정을 수행한다. 
3.  데이터베이스에 발생되는 트랜잭션의 유형을 파악한다. 
4.  용량과 트랜잭션의 유형에 따라 반정규화를 수행한다. 
5.  이력 모델의 조정, PK/FK 조정, 슈퍼타입/서브타입 조정 등을 수행한다. 
6.  성능 관점에서 데이터 모델을 검증한다. 

#### 3\. 성능 데이터 모델링을 할 때 고려사항

1.  정규화가 항상 조회 성능을 저하시키지 않는다. 기본적으로 중복된 데이터를 제거함으로써 조회 서능을 향상시킬 수 있다. 
2.  용량산정은 전체적인 데이터베이스에 발생되는 트랜잭션의 유형과 양을 분석하는 자료가 되므로 성능 데이터 모델링을 할 때 중요한 작업이 될 수 있다. 
3.  물리적인 데이터 모델링을 할 때 PK/FK의 칼럼의 순서조정, FK인덱스 생성 등은 성능 향상을 위한 데이터 모델링 작업에 중요한 요소가 된다. 
4.  이력데이터는 시간에 따라 반복적으로 발생이 되기 때문에 대량 데이터일 가능성이 높아 특별히 성능을 고려하여 칼럼 등을 추가하도록 설계해야 한다. 

\* 37번, 38번

4\. 정규화

\- 중복속성에 대한 분리가 1차 정규화의 대상이 되며, 로우단위의 중복도 1차 정규화의 대상이 되지만 칼럼 단위로 중복이 되는 경우도 1차 정규화의 대상이다. 

\- 

#### 5\. 반정규화

: 정규화된 엔터티, 속성, 관계에 대해 시스템의 성능향상과 개발과 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터모델링 기법

*   데이터를 중복하여 성능을 향상하기 위한 기법
*   성능을 향상시키기 위해 정규화된 데이터 모델에서 중복, 통합, 분리 등 수행하는 모든 과정

_\- 데이터 무결성이 깨질 수 있으나, 반정규화를 하는 경우_

*   데이터를 조회할 때 디스크 I/O량이 많아서 성능이 저하되는 경우
*   경로가 너무 멀어 조인으로 인한 성능저하가 예상되는 경우
*   컬럼을 계산하여 읽을 때 성능이 저하될 것이 예상되는 경우 

#### 6\. 데이터 모델에 대한 반정규화를 고려할 때 판단요소 

*   다량의 데이터 탐색의 경우, 인덱스가 아닌 파티션 및 데이터 클러스터링 등의 다양한 물리 저장 기법을 활용하여 성능 개선을 유도
    *   다만, 하나의 결과셋을 추출하기 위해 다량의 데이터를 탐색하는 처리가 반복적으로 빈번하게 발생한다면 반정규화 고려
*   이전 또는 이후 위치의 레코드에 대한 탐색은 window function으로 접근 가능하다. 
*   집계 테이블 이외에도 다양한 유형(다수 테이블의 키 연결 테이블) 에 대하여 반정규화 테이블 적용이 필요할 수 있다. 

![](https://blog.kakaocdn.net/dn/t8T2U/btsIVjcdeF9/FNA3entVIqmiYu5uCVu7V0/img.png)![](https://blog.kakaocdn.net/dn/rsfdq/btsIWxUUIOO/2lzWmFCOjcikglvj7iVnhk/img.png)

#### _\* 한 테이블에 많은 칼럼들이 존재할 경우_ 

데이터가 물리적으로 저장되는 디스크 상에 넓게 분포할 가능성이 커지게 되어 _**디스크 I/O가 대량으로 발생**_할 수 있다. 

\-> 이로 인해 _**성능이 저하**_될 수 있다. 

트랜잭션이 접근하는 컬럼유형을 분석해서 _**자주 접근하는 칼럼들과 접근 빈도가 낮은 칼럼들을 구분하여 1:1로 테이블을 분리**_

\-> 디스크 I/O가 줄어들어 성능을 향상 시킬 수 있다. 

**테이블 내에서 칼럼의 위치를 조정**하는 것은

\-> **_데이터 주로 채워지는 칼럼을 앞쪽에 위치_**시키고, 데이터가 채워지지 않고 _**주로 NULL 상태로 존재하는 칼럼들을 뒤쪽**_에 모아둔다. 

\-> 로우의 길이를 어느 정도 감소시킬 수 있으나, _**NULL 상태이던 칼럼에 나중에 데이터가 채워지게 될 경우 더 많은 로우 체인이 발생**_할 수 있기 때문에 바람직한 해결책이라고 보기 부족하다. 

**데이터가 채워지지 않고 NULL 상태로 존재하게 되는 칼럼들이 많이 나타나는 경우**는,

*   너무 많은 엔터티들에 무리하게 동질성을 부여하여 통합을 수행할 때
*   예측하기 어려운 미래 시점을 겨냥하여 과도하게 의욕적으로 속성을 확장한 경우 발생

\-> 자주 사용되는 칼럼들이나 현시점에서 주로 사용되는 칼럼들을 한데 모으고, 사용빈도가 낮은 칼럼들이나 미래 시점에서 사용될 것으로 예상되는 나머지 칼럼들을 한데 모아 별도의 _**1****:1 관계 엔터티로 분리**_하는 등의 데이터 모델 설계 수정을 고려해보는 것이 좋다. 

*   로우체이닝: 데이터베이스 테이블에서 데이터가 수정되거나 업데이트될 때 발생할 수 있는 현상
    *   한 블록에 저장된 행의 크기가 증가하여 그 블록에 더 이상 수용할 수 없을 때 발생 
    *   이 경우, DBMS는 그 행의 나머지 데이터를 다른 블록에 저장하게 되며, 이때 두 블록 간에 체인(연결)이 형성된다. 
    *   로우체이닝 영향: 성능 저하, 복잡한 관리 

* * *

#### 7\. 반정규화 절차

1\. 반정규화 대상조사

2\. 다른 방법 유도 검토

3\. 반정규화 적용

\- 범위 처리 빈도 수 조사  
\- 대량의 범위 처리 조사  
\- 통계성 프로세스 조사  
\- 테이블 조인 개수

\- 뷰(VIEW) 테이블  
\- 클러스터링 적용  
\- 인덱스의 조정  
\- 응용애플리케이션

\- 테이블 반정규화  
\- 속성의 반정규화  
\- 관계의 반정규화

#### 8\. 반정규화의 대상에 대해 다른 방법으로 처리

*   지나치게 많은 조인(JOIN)이 걸려 데이터를 조회하는 작업이 기술적으로 어려운 경우 
    *   뷰(VIEW)를 사용하여 해결
*   대량의 데이터처리나 부분처리에 의해 성능이 저하되는 경우
    *   클러스터링을 적용하거나 인덱스를 조정한다. 
*   하나의 테이블에 많은 양의 데이터가 저장되면 인덱스를 추가하고 테이블을 몇 개로 쪼개도 성능이 저하되는 경우
    *   대량의 데이터는 Primery Key의 성격에 따라 부분적인 테이블로 분리할 수 있다. 
    *   파티셔닝 기법(Partitioning): 논리적으로는 하나의 테이블이지만 물리적으로는 여러 개의 테이블로 분리하여 데이터 액세스 성능도 향상시키고, 데이터 관리방법도 개선할 수 있도록 테이블에 적용하는 기법 
*   응용 애플리케이션에서 로직을 구사하는 방법을 변경한다. 

#### 9\. 슈퍼/서브 타입 데이터 모델의 변환기술

*   **개별로 발생**되는 트랜잭션 -> **개별 테이블**로 구성 
*   **전체를 하나로 묶어** 트랜잭션이 발생할 경우 -> **하나의 테이블**로 구성 
*   **슈퍼타입 + 서브타입**에 대해 발생하는 트랜잭션 -> **슈퍼타입 + 서브타입 테이블**로 구성
    *   슈퍼타입, 서브타입: 데이터베이스 설계에서 엔터티 간의 상속 관계를 나타내는 개념   
        *   슈퍼타입
            *   공통의 특성을 가지는 일반적인 엔터티
            *   여러 서브타입이 공통으로 가지는 속성과 행위를 정의
            *   슈퍼타입 테이블은 공통 속성을 저장하는 테이블 
        *   서브타입
            *   슈퍼타입의 특성을 상속받는 더 구체적인 엔터티
            *   추가적인 속성이나 행위를 가질 수 있으며, 슈퍼타입에는 없는 특수한 속성이다.
            *    서브타입 테이블은 서브타입에 특화된 속성을 저장하는 테이블 
    *   _이러한 구조는 데이터의 중복을 최소화하고 데이터의 일관성을 유지하는 데 유리하다._ 

UNION: 데이터에서 중복된 행을 제거해야 하는 경우, 성능이 느릴 수 있음

UNION ALL: 중복된 행을 허용하고 더 빠른 성능이 필요한 경우, 더 빠른 성능 제공 

\* 트랜잭션은 항상 전체를 통합하여 분석 처리하는데 슈퍼-서브타입이 하나의 테이블로 통합되어 있으면 하나의 테이블에 집적된 데이터만 읽어 처리할 수 있기 때문에 다른 형식에 비해 더 성능이 우수하다. 

#### 10\. PK 순서를 결정하는 기준 

: 인덱스 정렬구조를 이해한 상태에서 인덱스를 효율적으로 이용할 수 있도록 PK 순서를 지정 

\- 여러 개의 속성이 하나의 인덱스로 구성되어 있을 때 앞쪽에 위치한 속성의 값이 비교자로 있어야 인덱스가 좋은 효율을 나타낼 수 있다. 

\- 앞쪽에 위치한 속성 값이 가급적 '=' 또는 최소한 범위 'BETWEEN' ' < >' 이 들어와야 인덱스를 이용할 수 있는 것이다. 

인덱스는 값의 범위에 따라 일정하게 정렬이 되어 있으므로

1.  상수값으로 EQUAL 조건으로 조회되는 칼럼이 가장 앞으로 나오고
2.  범위 조회 하는 유형의 칼럼이 그 다음에 오도록 하는 것이 

인덱스 엑세스 범위를 좁힐 수 있는 가장 좋은 방법이 된다. 

#### 11\. 분산 데이터베이스 장단점

장점

단점

\- 지역 자치성, 점증적 시스템 용량 확장  
\- 신뢰성과 가용성  
\- 효용성과 융통성  
\- 빠른 응답 속도와 통신비용 절감  
\- 데이터의 가용성과 신뢰성 증가  
\- 시스템 규모의 적절한 조절  
\- 각 지역 사용자의 요구 수용 증대 

\- 소프트웨어 개발 비용  
\- 오류의 잠재성 증대  
\- 설계, 관리의 복잡성과 비용  
\- 불규칙한 응답 속도  
\- 통제의 어려움  
\- 데이터 무결성에 대한 위협

_엔터티 간에 논리적 관계가 있을 경우_

( = 엔터티 간에 관계를 정의하여 관련 엔터티 상호 간에 업무적인 연관성이 있음을 표현한 경우 )

: 데이터들이 업무적으로 밀접하게 연결되어 상호 간에 조인이 자주 발생한다는 것을 의미 

\-> 데이터베이스 상에서 DBMS가 제공하는 FK Constraints를 생성했는지 여부와 상관없이

_**조인 성능을 향상시키기 위한 인덱스를 생성해주는 것**_이 좋다. 

**FK Constraints**

: 데이터 모델 상에 표현된 논리적 관계에 따라 관련 인스턴스 간에 일관성을 보장하기 위해 설계된 제약조건을 구현할 수 있도록 

DBMS가 제공해주는 하나의 '지원 기능' 

**Global Single Instance(GSI)**

: 통합된 한 개의 인스턴스, 통합 데이터베이스 구조를 의미 / 분산데이터베이스와 대치되는 개념

_마스터 데이터(공통코드, 기준정보 등)를 한 곳에 두고 운영하는 경우_, 

\- 원격지에서의 접근이 빈번할수록 실시간 업무처리에 대해 좋은 성능을 얻기 어려울 수 있다. 

\- _**분산 환경에 복제 분산을 하는 방법**_으로 분산 데이터베이스를 구성할 수 있다. 

\- 또한, _**백업 사이트 구성에 대해서 분산 환경으로 구성**_하여 적용할 수 있다.